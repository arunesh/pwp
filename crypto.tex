\section{Crypto economics, Mechanism design, Attacks on the system}
\subsection{Verifiable data structures}
Trillian stuff
\subsection{Attacks}
Possible attacks on the system
\subsection{Crypto economics}
How cryptonomics can be leveraged to prevent such attacks
\subsection{Mechanism design}
How is the system constructed to make sure that desired outcome is achieved

In this Section we discuss how Picolo handles failures and malicious nodes at the Database and the Network layer. Our mechanism design consists of these main pieces:
Nodes need to put up a stake before they can join the network
Usage of byzantine paxos
Usage of trillian and writing checkpoints to a separate blockchain (ethereum most likely)
Incentivizing nodes for correct behavior

We aim to devise Casper FFG style slashing conditions based on the detection of violation of conditions of 2 and 3 above.

Assumptions in the Attack model:

We assume a standard Byzantine failure model, i.e., the attacker is able to make changes to the messages at the Network layer on a node or alter the behavior at the Database layer for the node. The attacker is also able to coordinate the behavior of multiple nodes in real-time to achieve a desired attack scenario. We also allow for the adversary to delay communication between honest nodes so long as the adversary has the ability to do so given the topology of the overlay network (i.e. the adversary should be part of the routing path).

We also assume that the attacker is computationally bound, i.e., they cannot gather enough computing resources to subvert state-of-the-art cryptographic techniques such as Elliptic curve, crypto-hash functions (such as SHA-256) or encryption schemes such as AES.

Byzantine behaviour at the Database layer:

The central tenet of our design is to use strong cryptographic primitives to push the Byzantine behavior at the Database layer down to either a DoS style attack vector or to the network layer where we handle it using a combination of crypto-incentives, DHT management and detection.

At the Database level, each node is responsible for the standard CRUD operations for a given table (or a shard). Each such operation is protected using a cryptographic signature of the entity (dapp or user) that authorizes the request. Thus a malicious node is only able to destroy the data and not alter it. For example, every write request has a signature that certifies the request. Thus, a Merkle proof audit and signature on every table can deter any malicious manipulation of the data stored. 

The only attack vectors that remain are various versions of DoS style disruption, where a single node or a collection of nodes disrupt the network by delaying messages or destroying the data stored. 

Network level Byzantine behavior:

Here we discuss how to handle attack vectors where the adversary can drop network messages, delete data or both. 

The routing layer is based on a cryptographic DHT. Thus, it is not possible for the attacker to “choose” to store a particular shard or content. The only way an attacker can do a targeted DoS is by flooding the network with a majority of nodes such that with high probability one of the compromised nodes gets the responsibility for a targeted table or shard. This mapping includes the backup nodes, thus limiting the effectiveness of a targeted attack.
Caching and replication layer incentivizes faster network links and nodes:
The caching and replication layer prioritizes faster network links and nodes to serve requests. Thus, nodes that are dead, unresponsive or slow will get fewer requests over time. Thus, a DoS style attack scenario will cause diminishing impact over time.
While the network adapts to such a disruption, it is possible for the attacker to gain enough stake and temporarily cause a slowdown.
However, their stake (or trust level) would go down and they would be responsible for fewer network functions over time essentially degrading their involvement over time.	
Detection: It is be possible to detect such DoS style behavior quickly at the network layer since the overlay topologies tend to share many links at the layer-3 on the Internet. For example, if a node appears to delay messages at the network level while maintaining fast routes and content availability might indicate malicious intent.
The detection “service” can run on the nodes with the maximum stake or trust. They can detect anomalies between different layers of a potentially malicious node and agree to reduce the trust level of that node.
Such a detection service can only be thwarted if the malicious node coordinates its behavior across all observable metrics such that it appears as if it is naturally faulty. For this case, it is indistinguishable from a genuinely faulty node for all practical purposes which is handled at the DHT layer (node addition, deletion, failure modes).
