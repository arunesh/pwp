\section{Network Subsystem} 

The network layer is a fully decentralized, peer-peer overlay routing layer among the nodes participating in the Picolo database network. The most important
goal of the network layer is to help locate content as efficiently and quickly as possible while surviving certain kinds of failure or malicious intent. Peer-peer networking literature refers to this functionality as Decentralized Object Location and Routing (DOLR) \cite{dolr2003}. The network layer focuses on routing messages, such as database queries, read/write requests or other management functions to the respective nodes which can satisfy them. 

The overlay layer can be implemented on top of any datagram network protocol such as UDP or IP. Specifically on the Internet, we realize its implemented on IP or IPv6 protocols.
The peer-to-peer overlay routing infrastructure offers efficient, scalable, location-independent
routing of messages directly to nearby copies of an object or service using only localized resources [TP].

-- Self-repairing.
-- Soft-state based routing.

\subsection{Background}

History of unstructure p2p netoworks.
History of DHTs, examples, consistent hashing.

Talk about Chord, Pastry, Tapestry, Kademlia.

{\em Consistent Hashing:} 

In Picolo, we use consistent hashing as a basic mechanism to distribute, replicate and locate content on the network.
Typical hashing based schemes do a good job of spreading load through a known, fixed collection of servers. Since the
Blockchain consists of nodes on the Internet which can appear and disappear based on incentives and other criteria, our
assumption is that machines come and go as they crash or are brought into the network. Also,
the information about what nodes are functional propagates slowly through the
network, so that clients may have incompatible “views” of which nodes are available to replicate data. (Note that a
node can also be a client). This makes standard hashing useless since it relies on clients agreeing on which nodes are responsible for serving a particular
page.

%For example, Feeley et al [3] implement a distributed global shared memory system for a network of workstations
%that uses a hash table distributed among the machines to resolve references. Each time a new machine joins the network,
%the require a central server to redistribute a completely updated hash table to all the machines.  Consistent hashing
%may help solve such problems.

Like most hashing schemes, consistent hashing assigns a set of items to buckets so that
each bin receives roughly the same number of items.  Unlike standard hashing schemes, a small change in the bucket set
does not induce a total remapping of items to buckets. In addition, hashing items into slightly different sets of
buckets gives only slightly different assignments of items to buckets. 

\subsection{Design of the Picolo overlay network}

Picolo naming layer: 
1. Nodes and content map to a single 256-bit space. We can use existing hash functions such as SHA-256 for this purpose.

This space can be segregaged using a namespace identifier, which allows multiple such "naming layers" to co-exist. For example, one way to assign naming layers could be based on a per-application type.

For the rest of this section, the discussion gets isolated to within a single naming layer.

\subsection{Core API}

\subsection{Routing and Lookup}
Explain how a DHT works. Add a layer that takes care of data locality

\subsection{Node Dynamics}

Failures, node departures, node additions.

\subsection{Replication and caching}
Beehive stuff for O(1) lookups for power law queries

\subsection{P2P Connectivity protocol}
Use gossip or some other protocol to maintain network topology, connections

\subsection{Cryptoeconomics}
How will malicious nodes affect the system and how to mitigate/prevent/recover. Do nodes have incentive to participate in network discovery

\subsection{Analytics and Debug/Fault diagnosis}
